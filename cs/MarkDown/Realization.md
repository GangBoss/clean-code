1. вводится структура которая по виду токена умеет проверять наличие тэга TagParser.IsOpeningTag(line,index) TagParser.IsClosingTag(line,index)
2. Идем поэлементно и смотрим на тэги, пытаемся искать каждый раз открытые и складываем в открытые и закрытые
3. осуществляется проход по всему параграфу, каждую интерацию все имеющиеся TagParsers пытаются сложить в общий лист TagOppened новый Tag(открытый но не закрытый, если находят) для упрощения-поиск идет только когда символ числится в хэшсете "Интересных" А в специальный словарик складывают закрытые
_4. но проблема в следующем есть тэги А Б С
внутри А не работает Б но работает С
порядок открытия следующий А Б С Б С А
тогда мы сложили ББ и удалили С из очереди а потом добавили А выкинув Б но на деле должно было остаться А С С А
Поэтому видимо пойду строить какое нибудь дерево тэгов , но пока ещё рисуюсь на бумажке_

нужно найти
1. словарь открываемых тэгов по позиции (знаем начло и название тэга) 
2.наборы позиций где открываются (идем по всем)
3. словарь ВидТокена - двусвязный список закрываемых (когда взяли открываемый символ- ищем и закрываем его)


1. идем по всем открытым тэгам и сразу закрываем добавляя в дерево(по индексу находим родителя, если уже есть закрытый тэг который мы добавили и новый находится внутри, то этот закрытый-родитель) при этом если мы закрыли на индексе n то из открытых элемент на индексе n нужно удалить
2. получили дерево, дерево превращаем в набор токенов начиная с корня видимо

__так в примере 4 получится дерево АА-> ББ -> СС и при парсенге мы ББ отбросим__